数组名：int a[4];
	a通常情况下表示首元素的地址&a[0]
	例外： &a 表示整个数组的地址
	      sizeof(a)  得到的是整个数组的大小

m[ n ] === *(m+n)


sizeof(&a)      ---  地址值，32位机对应大小为 4B
	

int a[4] = 只有初始化才能一次性为多个元素赋值
	 如果是非定义时，希望为数组元素赋值，只能逐个赋值
		a[0]--- a[3]
		 GNU- C 在编译的时候 是不会检查数组是否访问越界
	 对于字符串char arr[10]这种情况可以用strcpy来实现赋值



指针：
	存放地址的变量   指针变量
	int * p ; 定义指针变量p 如果是局部变量p中随机值  int *表示指针类型
	
	int a = 100;  变量a的值为100
	int *q = &a;  指针变量q的值为a的地址  

	使用  q  === &a
	     *q  === *（&a） ==== a 解引用



数组指针
	指向整个数组的指针
	int a[4] =  {1,2,3,4} ;
	int *p = a ;    \\  Int *  指向一个int大小
	int (*q)[4] = &a  \\   int (*) [4]   表示指向4个int大小
		
	p+1  ==== a+1 === &a[0] +1  === &a[1]

	q+1 ===== &a + 1  // 越过了整个数组a

	一个指向有10个整型数数组的指针
		int (*q)[10]



指针数组
	由指针构成的数组
	
	int a[4] = {1,2,3,4};   

	int * x[4] = { &a[0] , &a[1] , &a[2], &a[3]};   数组x由4个int类型的指针构成，赋值的是也要使用int地址

	x[0]  ===== &a[0] ===== *x 
	x[1]  ===== &a[1] ===== *(x+1)



数组指针数组
	由5个数组指针构成的数组 , 数组指针指向的数组由4个int类型的数据构成
		int (*x[5])[4]    	 数组中的元素 int (*）[4]




函数
	实现固定功能
	
    定义函数

	存储类型 返回值类型 函数名（形参）
	static int func( int a, char b) // func （3， 5） ===>  int a = 3, int b = 5
	{
		// a , b
		return int类型的数据;
	}


	void func2(int a) // func2(10);   表示Int a=10   ； void表示不能返回值
	{
		// a
		return；  // return后面不能带值 ，比如不能写成return 0;
	}

	void func3( void) // func3() ;    （void )不能传参数
	{
		// 
		return ;
		
	}
	

	char * func4( int a , char *b )
	{
		// a  b
		返回值为char *类型 ,char 指针类型
	}
	
		
	指针函数 返回值为指针的函数


	函数的声明 ， 可以省去变量名，但是要有变量的类型
		static int func( int a, char b); ==》 static int func( int , char ) ;
		void func2(int a)； === 》 void func2(int )；
	


	

	基于sushu.c  要求func的传入的参数和返回值都是字符串， 这时候怎么去更改？ 
		sushu2.c:44:2: warning: function returns address of local variable [enabled by default]
		编译的是会提示企图返回本地变量的地址值 ，操作不安全
	


	函数传参要注意的问题：
	1： void upper_case(char str[10]) // 形参中的数组定义是骗人的， 形参中的char str[] 等于是char *str 
	你看到的数组名其实是个指针变量 , sizeof(str) 是指针变量的大小
	
	如果你不是用sizeof来计算数组的长度就不受影响，
	如果在函数中需要计算数组的长度，建议是传参时候把数组的长度传过来

	2：在遇到指针传参的时候，要注意更改的值是哪个，注意画图理解
	   一级指针也不一定可以更改原值
	  详见 get_memory.c  get_memory2.c  


	


局部变量 只能在本函数中使用 ，从定义处到对应的}结束
	局部变量
		1: { } 中定义的变量 
		2： 形参
		存在于栈中， 压栈出栈 ，函数运行结束的时候会释放地址


	 静态局部变量
		static  修饰的是局部变量的话，证明这个局部变量是静态的
			存在数据段中（整个程序刚运行时候就已经存在了）
			如果没有初始化，.bss 会自动设置为0
			每次使用的是上一次的设置值，只会在整个程序刚运行的时候被初始化一次
			整个程序运行结束才释放

			
		

全局变量 
	都在数据段中（整个程序刚运行时候就已经存在了）
	如果没有初始化，.bss 会自动设置为0
	每次使用的是上一次的设置值，只会在整个程序刚运行的时候被初始化一次
	整个程序运行结束才释放


	普通全局变量，可以被其它的文件调用（需要加上extern 声明 ）
		独立于所有{}之外的叫全局变量
		

	静态全局变量，只限于在本文件中使用 
		用static 修饰的全局变量只能在本文件中使用
		


--------------------------------------------------------------
如果局部变量和全局变量同名
优先选择自家的局部变量
---------------------------------------------------------------


函数  
	普通函数 
		如果是在其它文件中调用，最好写上extern 声明 

	静态函数
		只能在本文件中使用的 ，static 





.h 文件 
	头文件
	
	stdio.h

	#ifndef _STDIO_H       //也可以是 __STDIO__H__  作用是防止头文件被重定义
	#define _STDIO_H 
	
	#endif
	
	#include <>   在系统的环境变量PATH中寻找对应的.h文件
	#include “”  在自定义路径中寻找对应的.h文件

	在编译的时候是会被展开的
	建议不要在头文件中定义一个全局变量，如果你定义全局变量是赋初值的，会提示
	“/tmp/cc0NKkLR.o:(.data+0x0): multiple definition of `c'
	/tmp/ccvuTkWt.o:(.data+0x0): first defined here
	collect2: ld returned 1 exit status”
	建议只在头文件中做变量声明


	练习：  
	编写一个函数，它返回函数自身被调用的次数，并在一个循环中测试之。
		 静态局部变量


堆空间使用
	栈空间 由系统根据运行的函数决定使用情况， 某函数运行完了对应的栈空间就会释放
	数据段 程序刚开始运行时候就决定使用情况，程序结束的时候才会释放

	堆空间 由程序员决定什么时候申请/释放空间 动态空间

		申请空间 大小为偶数个字节
			 #include <stdlib.h>

      			 void *malloc(size_t size);
			 void *calloc(size_t nmemb, size_t size); 申请了空间之后再把空间中的值清零

			 申请100字节堆空间
			 void * p = malloc(100);   
			 *(int *)p = 1   仅仅是把指针p由通用指针强制转换成int指针再解引用，并赋值
			 *((int *)p+1) = 100   

			 申请100字节堆空间给int数据使用
			 int *p = (int *)malloc(100)	堆空间数据是随机值
			 int *p = (int *)calloc (4, 25); 保证堆空间数据初始化值为0；



		释放空间
			free（p）  堆空间的钥匙（首地址）不能丢，可以复制
				1： 如果free的不是堆空间首地址， 会段错误
				2： 如果重复free 会发生 double free or corruption引起的段错误Aborted (core dumped)
			 

		调整申请的空间大小
			p = realloc(p, 1000);
			可能会p值前后不一致
			把原来的数据都搬到新地址中，释放原来的空间

	



递归函数
	函数嵌套 函数自己调用自己  
	必须有终止递归的条件
		
	快速排序法 quick.c




回调函数（使用函数指针）


	注册( 遇到情况A ，要调用的函数)     // 信号处理注册函数signal   中断处理函数 
	
	int *p(int a )	指针函数p 返回值为int * , 形参为int
	
	int (*p) (int )    --- int (int )表示指向函数  (*p)强调是指针  函数指针
				指向（返回值是int ,形参为int的函数）的指针    
		

	函数指针 
	
	int func(int val);

	p = &func ======== p = func;
	
	调用对应的函数
	*p（100） ==== p(100)

	使用函数指针时候 & *这两符号是可以不写的
		
	关键是如何定义函数指针并指向合适的函数，

	
	
---------------------------------------------------------------------
Segmentation fault (core dumped)
  	企图对空地址做解引用
----------------------------------------------------------------------


作业：
	1、哪一存储类的变量在包含他们的程序运行时期内一直存在？哪一存储类的变量可以在多个文件中使用？哪一存储类的变	量只限于在一个文件中使用？

	2、代码块作用域变量具有哪种链接类型？

	3、说出C程序中所有不同的存储类变量在内存中的详细分布情况。

	4： 计算 1! + 2! + 3！ + 4！。。。。。 10!  递归 （选做）

	5： 编写一个函数， 要求可以实现计算字符串中小写字母的字节数， 使用函数指针在main函数中调用该函数，并显示结果
	6：  书上7、下面函数实现数组元素的逆转，请填写空白处使其完整。

	

QQ :2821537943